[<< Back to .NET>](index.md)

# LINQ
LINQ allows the creation of declarative code for operating on data as a first-class language construct.  It provides language-level querying capabilities and a higher-order function API.  It is especially useful for data access, as LINQ abstracts common elements of data access into a query syntax which looks the same no matter which data source you pick.  

LINQ has both query syntax and method / fluent API syntax.  There is no semantic or performance difference between the too, but query syntax can be more readable.  LINQ queries are compiled either to delegates or expression trees, depending on the type of query.  The query is distinct from the execution of the query, in a process known as deferred execution.  The query execution is deferred until actual data retrieval is necessary, usually through a `foreach` loop.  Aggregate query functions, like `Count` or `Max`, internally iterate over a dataset, even though a scalar value is returned.  Immediate execution can also be forced via `ToList` or `ToArray`.

Linq queries are typed as either `IEnumerable<T>` or a derived type such as `IQueryable<T>`.

# Extension Methods
Method syntax allows standard query methods to be executed against objects following the `IEnumerable<T>` interface.  However, this interface does not define any of these methods on the interface itself.  Rather, these methods are extension methods, or methods that extend an existing type and can be called as if they were instance methods on the type.  The standard query methods extend the `IEnumerable<T>` interface.

Extension methods do not require the creation of a new type, recompilation, or any other modification of the original type.  They are a special kind of static method that are invoked as if they were instance methods.  They are only in scope when the correct using statement is defined in code.  IL generated by compiler translates the code into a call into the static method.  Accordingly, extension methods cannot access private variables in the type they are extending.

It’s worth noting that extension methods should be used sparingly.  You should usually extend code by declaring new derived types.  Extension methods run the risk of breaking changes if the original type changes its implementation.  You should definitely not use extension methods to avoid incrementing the version number of an assembly.

# Anonymous Types
Anonymous types provide a quick way to encapsulate a set of read-only properties into a single object without having to explicitly define a type first.  The type name is generated by the compiler, and the type of each property is inferred.  No other kinds of class members are allowed.

# Expression Trees
An expression tree is a data structure that defines code. They are based on the same structures that a compiler uses to analyze code and generated compiled output.  The expression tree is a full representation of the code in tree format.  It can be converted into an executable delegate if desired.  They are also immutable data structures.

# LINQ Provider
LINQ providers implement the `IQueryProvider` and `IQueryable<T>` interfaces.  This allows data store providers to accept an expression tree from LINQ to be translated into any specific data stores’ native query language.  This is where LINQ’s deferred execution comes into play.  Instead of emitting IL for a delegate, an expression tree is created and the translation of that tree is deferred until real data is required.  Then, the LINQ provider takes the expression tree and outputs whatever is needed to query the data store and return data to LINQ.

This ability to treat expressions as data at runtime is critical to enable an ecosystem of third-party libraries that leverage base query abstractions.

# References
- [LINQ: .NET Language-Integrated Query](https://msdn.microsoft.com/en-us/library/bb308959.aspx)